import re
from typing import Dict, List

def extract_code_blocks(text: str) -> List[str]:
    return re.findall(r'```(?:\w+)?\n(.*?)```', text, re.DOTALL)

def calculate_complexity(code: str) -> int:
    # This is a simple complexity measure. In a real-world scenario,
    # you might use more sophisticated metrics like cyclomatic complexity.
    return len(re.findall(r'\bif\b|\bfor\b|\bwhile\b|\bdef\b|\bclass\b', code))

def aggregate_results(results: Dict[str, str]) -> str:
    code_blocks = {model: extract_code_blocks(result) for model, result in results.items()}
    
    if not any(code_blocks.values()):
        return max(results.values(), key=len)  # Fallback to longest response if no code blocks
    
    # Select the most complex code block
    all_blocks = [(model, block) for model, blocks in code_blocks.items() for block in blocks]
    best_block = max(all_blocks, key=lambda x: calculate_complexity(x[1]))
    
    # Prepare the final result
    chosen_model, chosen_code = best_block
    explanation = f"Code generated by {chosen_model} was selected due to its complexity and completeness."
    
    return f"{explanation}\n\nHere's the code:\n\n```\n{chosen_code}\n```"

# Update the _aggregate_results method in TaskDistributor to use this function
def _aggregate_results(self, results: Dict[str, str]) -> str:
    return aggregate_results(results)